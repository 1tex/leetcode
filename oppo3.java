//小欧拿了n个杯子排成了一排，其中有k个杯子装满了水，剩余的n-k个杯子为空的。小欧每回合的操作如下：
//        1. 随机选择一个杯子。
//        2. 杯子是空的。回合直接结束。
//        3. 杯子是满的。如果小欧上一回合喝过了水，则回合结束；否则将喝完这杯水，回合结束。
//
//        小欧想知道，她喝完所有水的回合数期望是多少？
//        输入描述
//        两个正整数n,k，用空格隔开。
//        1\leq k \leq n \leq 10^6
//        输出描述
//        一个浮点数，代表期望的回合数。如果你的答案和正确答案的误差不超过10^{-6}，则认为答案正确。
//        示例1
//        输入输出示例仅供调试，后台判题数据一般不包含示例
//        输入
//        复制
//        1 1
//        输出
//        复制
//        1.000000000
//        说明
//        只有一杯水，第一回合就可以喝完。
//        示例2
//        输入输出示例仅供调试，后台判题数据一般不包含示例
//        输入
//        复制
//        2 1
//        输出
//        复制
//        2.000000000
//        说明
//        有50%的概率1回合喝完，有25%的概率需要2回合 ，有12.5%的概率需要3回合……
//        总期望为0.5*2+0.25*3+0.125*4+……=2
//        示例3
//        输入输出示例仅供调试，后台判题数据一般不包含示例
//        输入
//        复制
//        2 2
//        输出
//        复制
//        4.000000000
//        说明
//        第一回合有100%的概率喝一杯水。
//        第二回合无论是否选到有水的杯子都不会喝水。
//        0.5*3+0.25*4+0.125*5+...=4
//        提交本题型
//


import java.util.Scanner;

public class oppo3 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), k = sc.nextInt();
        double[][] dp = new double[k + 1][2];

        for (int i = 1; i <= k; ++i) {
            dp[i][0] = 1.0 + (double) i / n * dp[i - 1][1] + (double) (n - i) / n * dp[i][0];
            dp[i][0] /= 1.0 - (double) i / n;
            dp[i][1] = 1.0 + (double) i / n * dp[i][0] + (double) (n - i) / n * dp[i][0];
        }

        System.out.printf("%.9f\n", dp[k][0]);
    }
}